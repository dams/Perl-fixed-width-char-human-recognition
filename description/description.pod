-*- encoding: utf-8; indent-tabs-mode: nil -*-

=encoding utf8

=head1 Introduction

Pendant l'hiver 2014-2015, j'ai décidé de
prendre un programme e-Lisp de
calendrier républicain dont les
racines remontent à plusieurs décennies
et de l'améliorer. Je ne vais pas
vous faire un exposé sur les
développements en e-Lisp,
je vais vous expliquer comment
j'ai initialisé un dépôt Git
avec des commits remontant à
1989.

=head1 Ooops !

Ooops, c'est l'exposé de l'année précédente pour les Journées Perl Francophones
de 2016. Permettez-moi de faire quelques adaptations.

  s/2014-2015/2016-2017/g;
  s/e-Lisp/Pascal/g;
  s/1989/1983-1984/g;

=head1 La véritable introduction

Pendant l'hiver B<2016-2017>, j'ai décidé de
prendre un programme B<Pascal> de
calendrier républicain dont les
racines remontent à plusieurs décennies
et de l'améliorer. Je ne vais pas
vous faire un exposé sur les
développements en B<Pascal>,
je vais vous expliquer comment
j'ai initialisé un dépôt Git
avec des commits remontant à
B<1983-1984>.

=head1 Circonstances

En 2012, j'ai retrouvé trois listings
de mes années étudiantes. Au lieu
des feuilles A4 imprimés au laser
que nous utilisons tous depuis
la fin des années 1980, c'était
des listings continus avec entraînement
par bande Caroll et sortant d'une 
imprimante à aiguilles.

Au début de chacun de ces trois listings,
j'ai écrit un commentaire pour donner la date.
Cette précision a été
le point de départ de mon projet,
récupérer les fichiers sources
I<à l'identique> et les soumettre à
Git avec cette date de commit.

=begin HTML

<img src="entete1.png" alt="Les 10 premières lignes du listing du 8 décembre 1983" />
<br /><img src="entete2.png" alt="Les 5 premières lignes du listing du 10 janvier 1984" />
<br /><img src="entete3.png" alt="Les 5 premières lignes du listing du 19 janvier 1984" />

=end HTML

=head2 Première méthode

Première méthode, tout recopier
à la main. Le problème, c'est qu'entre
1984 et 1990, j'ai affiné mon style
de programmation. Voici par exemple comment je codais en S<1984 :>

=for HTML
<img src="exemple-code.png" alt="Exemple de code montrant l'absence d'alignement vertical" />

Et voici le même extrait, mis en forme ainsi que je le fais depuis 1990 (au moins)

  case date.mois of
     1: gregnum := date.jour;
     2: gregnum := date.jour +  31;
     3: gregnum := date.jour +  59 + bissex(date.an);
     4: gregnum := date.jour +  90 + bissex(date.an);
     5: gregnum := date.jour + 120 + bissex(date.an);
     6: gregnum := date.jour + 151 + bissex(date.an);
     7: gregnum := date.jour + 181 + bissex(date.an);
     8: gregnum := date.jour + 212 + bissex(date.an);
     9: gregnum := date.jour + 243 + bissex(date.an);
    10: gregnum := date.jour + 273 + bissex(date.an);
    11: gregnum := date.jour + 304 + bissex(date.an);
    12: gregnum := date.jour + 334 + bissex(date.an);
  end;

Comme vous pouvez le voir, j'encadre les opérateurs tels que S<« C<:=> »> et S<« C<+> »>
de blancs pour améliorer la lisibilité et j'aligne verticalement les éléments semblables
dans les lignes successives, l'alignement se faisant sur la droite si les éléments alignés
sont numériques.
Ce qui ne se voit pas dans cet exemple, c'est qu'en 1984 j'utilisais des
tabulations et que maintenant, je préfère des espaces (sauf pour les I<makefiles>).

Et je ne pourrais pas
m'empêcher de rectifier le
programme pendant que je le recopie.
Donc j'ai laissé tomber cette méthode
I<a priori>.

=head2 Deuxième méthode

Deuxième méthode, scanner les listings
puis les passer dans un
programme de reconnaisance automatisée
de caractères. J'ai scanné le premier
listing puis je l'ai soumis à quelques
programmes OCR. Comme je m'y attendais,
le résultat a été catastrophique.

=head2 Programmes de reconnaissance automatisée de caractères

Avant de présenter la troisième méthode,
voici un aperçu des programmes de
reconnaissance de caractères.

Les programmes de reconnaissance de
caractères installés sur ma machine
fonctionnent en ligne de commande.
Il s'agit de :

=over 4

=item * gocr (L<http://jocr.sourceforge.net/>)

=item * ocrad (L<https://www.gnu.org/software/ocrad/>)

=item * tesseract (L<https://github.com/tesseract-ocr>)

=item * cuneiform (L<https://en.wikipedia.org/wiki/CuneiForm_(software)>)

=back

De ce que j'ai pu voir dans la logithèque
Ubuntu, les autres programmes disponibles
sont des habillages graphiques
de ces programmes, ou bien des
programmes très spécialisés.

Notons également que cuneiform propose
une option C<--dot-matrix> mais dans
mon cas, cela n'a rien donné de mieux
que la tentative sans cette option.

=head3 Remarque : reconnaissance automatisée, non pas optique

J'ai utilisé l'expression S<« reconnaissance> S<automatisée »> et non
pas S<« optique »> pour les programmes ci-dessus. Parce qu'ils ne font
pas de traitement optique.

Imaginez que vous fassiez l'expérience suivante. Vous créez un script
shell basé sur le schéma suivant :

  .                        ___
  .                       (   )
  .                       (___)_ /dev/random
  .                         |
  .                   ---------------
  .                   | script GIMP | (ou GD.pm)
  .                   ---------------
  .                       |   |
  .                  ------   ------
  .                  |             |
  .                 ___           ___
  .                (   )         (   )
  .    exemple.txt (___)_        (___)_ exemple.png
  .                  |             |
  .                  |      ----------------
  .                  |      |    GOCR      | ou OCRAD, ou Tesseract, ou Cuneiform
  .                  |      ----------------
  .                  |             |
  .                  |            ___
  .                  |           (   )
  .                  |           (___)_ exemple-2.txt
  .                  |             |
  .                  ------   ------
  .                       |   |
  .                   ---------------
  .                   |    diff     |
  .                   ---------------
  .                         |
  .                       -----
  .                       |  _|
  .                       |_/    /dev/stdout et /dev/stderr

Vous le transférez sur un serveur du « claoude », vous l'ajoutez à la
liste des tâches C<cron> de ce serveur pour qu'il s'exécute à 4h du
matin et vous coupez la communication avec ce serveur. Lorsque le
script s'exécute à 4h du matin, combien de rayons lumineux sont déviés
par une lentille ou réfléchis par un miroir ? Combien de photons
activent une surface photo-sensible (rétine, barrette CCD) ? Réponse :
zéro. Il n'y a rien d'optique dans ce traitement.

=head2 Le meilleur moteur de reconnaissance

Le meilleur moteur de reconnaissance de caractères
est basé sur des réseaux neuronaux et il nécessite
réellement des capteurs optiques.
Il a été publié pour la première fois
par une start-up libanaise ou, plus précisément,
phénicienne aux alentours de 1200 ans avant J-C.

=for HTML
<img src="U10900.png" alt="Codage Unicode de l'alphabet phénicien" />

Copie d'écran personnelle d'une page 
L<Wikipedia|https://fr.wikipedia.org/wiki/Alphabet_ph%C3%A9nicien>
licence L<Creative Commons attribution, partage dans les mêmes conditions|http://creativecommons.org/licenses/by-sa/3.0/deed.fr>

=for HTML
<img src="Liseuse.jpg" alt="La liseuse de Fragonard" />

La Liseuse, par Fragonard (1732--1806), œuvre dans le domaine public, avec quelques adaptations personnelles mineures.

Ce système admet plusieurs plug-ins, mais
à chaque fois, cela nécessite un temps
de paramétrage assez long.

=for HTML
<img src="geoffroy_henri_jules_en_classe_le_travail_des_petits.jpg" alt="Scène dans une école" />

En classe, le travail des petits, par Henri Jules Geoffroy (1853--1924), œuvre dans le domaine public. Avec un marquage par le site web où j'ai trouvé cette reproduction (pourquoi marquer une œuvre dans le domaine S<public ?)>

En revanche, les résultats sont
largement meilleurs que pour les
programmes ci-dessus.

Il y a des problèmes toutefois. Par exemple, avec cette image :

=for HTML
<img src='Leonov.jpeg' alt='Alexei Leonov en scaphandre' />

Source L<http://www.popscreen.com/p/MTU3MDkzMDU5/Soviet-CCCP-Astronaut-Space-Patch-Russian-Alexei-Leonov>

la plupart des systèmes donnent comme résultat S<« cécécépé »> (U+43 U+43 U+43 U+50),
alors qu'il faut lire en fait S<« essessessère »> (U+0421 U+0421 U+0421 U+0420).
Mais reconnaissons que les programmes mentionnés dans le chapitre précédent ne feraient pas mieux.

D'un autre côté, les systèmes de ce type peuvent détecter des caractères là où il 
n'y en a pas. Par exemple, vous les pointez vers S<Cassiopée :>

=for HTML
<img src='Cassiopee.png' alt='Représentation de la constellation Cassiopée' />

S<Source :> copie d'écran personnelle du logiciel L<Stellarium|http://www.stellarium.org/>

certains détecterons un S<« W »>, d'autres un S<« M »>. Idem 
L<en regardant dans l'autre sens|https://news.artnet.com/art-world/nasa-photos-alphabet-in-the-sky-400646>,
L<de l'espace vers la Terre|https://www.mapbox.com/blog/letter-hunt-from-space/>.

Ou bien dans ce dessin abstrait, certains y voient des mots entiers, en l'occurrence des S<prénoms :>

=for HTML
<img src='EstPhil.gif' alt='Dessin abstrait' />

S<Source :> dessin créé par L<GEF|http://www.gef.free.fr/ambigallery.html> utilisé ici avec l'autorisation des intéressés.

=head2 Programmes hybrides

En 2000 ou 2001, j'avais installé 
sur ma machine de l'époque un
programme original dont je ne trouve
plus aucune trace quinze ans
plus S<tard :> Alice-OCR.
Pour changer, c'était une application graphique,
pas un utilitaire en ligne de commande.
La moitié gauche de la fenêtre affichait
le fichier graphique à analyser et la moitié droite
affichait le texte résultat.
Vous lanciez une analyse et un premier
résultat s'affichait dans la partie droite.
S'il y avait des erreurs, vous pouviez
cliquer sur un glyphe de la partie graphique
puis indiquer la véritable transcription.
Ce n'était pas la peine de pointer
toutes les erreurs, mais seulement
un échantillon représentatif.
Ensuite, vous relanciez une analyse
et le résultat tenait compte
des corrections que vous aviez données.
Les associations glyphe -> caractère
pouvaient même être stockées dans
une base de données pour l'analyse
d'un autre fichier.

Il existe d'autres systèmes informatiques
reposant au moins en partie  sur la reconnaissance humaine
des caractères et qui gèrent leur
S<infrastructure :>

=over 4

=item * recaptcha

=item * Distributed Proofreaders (L<https://www.pgdp.net>) en amont du projet Gutenberg

=item * Openfoodfacts (L<https://fr.openfoodfacts.org/>).

=back

=head2 Troisième méthode

La méthode que j'ai adoptée en fin de compte
est inspirée d'Alice-OCR. Le programme assure
l'aspect logistique de la conversion
en gérant notamment une base de données
et la reconnaissance à proprement parler
est assurée par l'utilisateur humain.
À l'inverse de Alice-OCR, il n'y a pas
de première tentative avec un moteur de reconnaissance
informatique. Une autre différence est que
l'utilisateur a son mot à dire lors du
découpage du fichier graphique en cellules contenant un glyphe.

S<Note :> dans ce qui suit, je décris
les programmes au présent ou au passé,
mais j'ai écrit la première description
du système
I<avant> d'écrire la première ligne
de code. Bien sûr, si je dois changer mon
fusil d'épaule sur certains points,
je mettrai à jour la présente description.

=head1 Au travail

=head2 Technologies utilisées

Pour les fonctions graphiques, j'utilise C<GD.pm>. Je n'ai pas réussi
à installer l'interface entre Perl et the Gimp sur ma machine, donc je n'ai 
pas eu à choisir, j'ai pris C<GD.pm>.

Pour les fonctions peu interactives, j'ai utilisé bien entendu une interface
en ligne de commande.

Pour les fonctions interactives, j'ai décidé d'utiliser L<Dancer2|http://perldancer.org/>
et L<MongoDB|https://www.mongodb.com/what-is-mongodb>.
Dancer2 parce que cela fait longtemps
que j'en entends parler par Alexis,
Damien, Sawyer et d'autres. En plus, le module inclut
un serveur web. Certes, ce serveur ne supporterait
pas une charge de  plusieurs requêtes à la seconde,
mais comme mon appli est prévue pour un
seul utilisateur à la fois, c'est largement suffisant.
MongoDB, parce que je connais déjà SQL et
cette application ne m'aurait pas donné l'occasion
d'apprendre des techniques avancées de SQL.
Alors j'ai chaisi de faire mes premiers pas en MongoDB.
Et peut-être PDL si cela permet des comparaisons faciles
de matrices de booléens.

Plan S<B :> pas de plan B pour C<GD.pm>, je sais que cela fonctionne et que je saurai
me débrouiller avec. Si je n'arrive pas à m'en sortir avec MongoDB, tant pis, je
ferai du SQL avec SQLite. Et pour Dancer2, je ferai du CGI à l'ancienne, comme lorsque
j'ai commencé à utiliser Perl il y a 19 ans.

Et bien sûr, j'utilise Perl. S<Perl 5> ou S<Perl 6 ?> Bonne question.
Comme j'ai reçu mon premier livre sur Perl 6 juste avant d'initialiser
mon dépôt Git et d'écrire la première ligne de code exécutable,
j'ai eu le temps de constater qu'il existait une variante de Dancer
pour Perl 6, Bailador. Ensuite, en consultant la liste des modules Perl 6
sur L<http://modules.perl6.org/>, j'ai vu qu'il existait aussi un
module GD et un module MongoDB. Hélas, je n'ai pas pu utiliser la méthode
C<newFromPng> du module GD, la méthode cruciale qui me permet d'utiliser les
listings numérisés. Donc, Perl 6, ce sera pour une autre fois.


=head1 Numérisation des listings

Comme vous pouvez le constater sur les
reproductions des listings, il y a plusieurs
éléments perturbateurs pour numériser les
fichiers.

Tout d'abord, la largeur.

En fait non, en pratique le problème
est minime. Sur les trois listings,
il y a un nombre très faible de lignes trop
longues pour le format A4, une demi-douzaine en comptant celles où
le dernier point-virgule ou la dernière accolade manque. Donc, je peux me
permettre une reprise manuelle de ces
lignes une fois le processus terminé.

Les bandes Caroll ensuite, ou plus précisément
la bande gauche. En plaçant correctement
le papier au moment de la numérisation,
la bande Caroll est éliminée sans coup férir.
Et si elle apparaît quand même, une intervention
élémentaire sous the Gimp la fait disparaître.

Le troisième écueil, plus gênant,
est que pour le deuxième listing, le ruban
encreur était plutôt fatigué.
Alors que j'ai pu numériser le premier listing
en noir et blanc, en conservant les
caractères et en éliminant les lignes
pré-imprimées, cela n'a pas été
possible avec le deuxième. Selon le
réglage du scanner, soit les lignes étaient
éliminées mais les caractères étaient
mutilés, soit les caractères étaient complets,
mais des morceaux de ligne persistaient.

La solution a consisté à scanner ce listing
en couleurs, de manière à pouvoir ensuite
traiter chaque pixel en fonction de
ses caractéristiques HSV (en anglais
I<hue, saturation, value>
et en français
teinte, saturation, valeur).

Un premier programme me permet de savoir quelle est la plage de valeurs
des caractéristiques HSV. J'aurais pu fouiller la documentation, j'ai préféré
écrire un programme qui a l'autre avantage de me servir de modèle pour les suivants.
Et à la réflexion, j'ai bien fait, car j'ai découvert que la fonction de conversion
de RGB vers HSV produisait des nombres négatifs, ce qui est contraire à la documentation.
J'ai donc patché C<GD::Simple> et j'ai soumis un ticket 
L<https://rt.cpan.org/Ticket/Display.html?id=120572>.

J'ai complété ce premier programme pour calculer également la moyenne et le mode
(la valeur qui apparaît le plus souvent) de chacune des caractéristiques RGB et HSV.
Certes, comme la teinte H est de nature cyclique, le calcul de la moyenne n'a pas
de signification réelle. Mais le mode, si. Et pour les cinq autres caractéristiques, 
la moyenne et le mode ont une signification réelle.

À l'origine, j'avais l'intention d'écrire
un deuxième programme pour construire un histogramme
des données H et V (je ne saisissais pas très
bien ce que représente la saturation,
donc j'ai l'intention de faire l'impasse). Mais je me suis renseigné sur
les valeurs HSV et j'ai compris que la saturation avait
son importance. D'autre part, avec les schémas en
L<https://en.wikipedia.org/wiki/HSL_and_HSV#HSV>,
je n'avais plus besoin d'un histogramme.

Un troisième programme (devenu second programme) passe en revue
tous les pixels des fichiers graphiques.
Pour chacun, s'il est plus clair qu'un
certain seuil, le programme le remplace par un
pixel blanc, s'il est plus foncé que
ce seuil il le remplace par
un pixel noir. Le point essentiel est
que ce seuil dépend de la teinte H.
Pour le bleu, ce seuil est plutôt clair,
tandis que pour l'orange il est
plutôt foncé. De la sorte, un
pixel bleu moyen deviendra noir
alors qu'un pixel orange moyen
deviendra blanc.

Dans ce diagramme, j'ai représenté la frontière entre la
zone de conversion vers le blanc et la zone de conversion vers le noir.

=begin HTML

<img src="diagramme-HSV.png" alt="Diagramme HSV pour le bleu et l'orange" />

<p><font size='2'>Copie d'écran personnelle d'une page Wikipedia avec des modifications mineures. Comme indiqué dans la page Wikipedia,
<i lang='en'>Text is available under the Creative Commons Attribution-ShareAlike License; additional terms may apply.</i></font>
</p>

=end HTML


À noter un problème culturel.
Né dans les années 1960, j'ai appris
le dessin avec des crayons de couleurs,
et du papier,
pas avec the Gimp ou assimilé. Donc, pour
moi, S<« rien »,> c'est une feuille blanche,
et S<« plein> de S<couleurs »,> cela tend à donner
du noir. Or c'est l'inverse dans les
logiciels graphiques avec les valeurs RGB
ou avec le V des valeurs S<HSV :>
plus c'est faible, plus c'est noir
et de l'autre côté, plus c'est
élevé, plus cela se rapproche du blanc.

Un dernier écueil, le plus important, les irrégularités des glyphes.

L'imprimante faisait du S<10 CPI> et du S<6 LPI.> Mon scanner
fait du S<300 DPI.> Cela veut dire que chaque glyphe
correspond à un rectangle de S<30x50 pixels.>
Cela laisse le champ libre à une énorme variabilité
dans les dessins bitmaps d'un caractère donné.
Voir les exemples dans les copies d'écran.

INSÉRER COPIE D'ÉCRAN

D'où un traitement pour réduire cette variabilité.
Je passe en revue tous les pixels d'un fichier graphique.
Si un pixel est entouré d'une majorité de voisins de la couleur opposée,
alors il change de couleur. Cela permet d'enlever les
verrues et les gerçures sur les frontières entre
le blanc et le noir et cela permet d'enlever la poussière
(pixels noirs isolés).

Le programme de lissage et de nettoyage permet de faire au choix une seule
ou plusieurs itérations en fonction d'un paramètre au lancement.
Un autre paramètre permet de prendre en compte les
diagonales S<(8 voisins> par pixel) ou pas S<(4 voisins).>
Finalement, le programme génère deux fichiers
S<graphiques :> le premier avec des pixels noirs et blancs
pour la suite du projet, le deuxième avec des pixels de
couleurs pour visualiser ceux qui ont été touchés
par le nettoyage et les distinguer de ceux qui n'ont pas
changé de couleur. Cela me permet de mieux apprécier
le fonctionnement de l'algorithme de lissage et
de nettoyage.

=for HTML
<img src="resultat-lissage.png" alt="Extrait d'un listing avant et après lissage, avec au milieu la visualisation des différences" />

En réfléchissant un peu, je me suis aperçu que la variante
avec 8 voisins aurait émoussé les coins à angle S<droit :>

  ..***      ..***
  ..***      ..***
  ..***  ->  ...**
  .....      .....
  .....      .....

J'ai donc pris la variante à 4 voisins. Et il suffit d'une génération
pour avoir un bon nettoyage. D'un autre côté, comme on peut le deviner dans
le schéma ci-dessus, certains S<« fossés »> comme dans le trait horizontal supérieur
du S<« p »> auraient été comblés avec la version à 8 voisins, alors qu'ils ne le seront
pas avec la version à 4 voisins.

On peut considérer que c'est une variante
du Jeu de la Vie de Conway (John, pas Damian),
avec des règles de transition différentes.

La variabilité des glyphes est réduite, mais elle existe encore.

=head1 Reconnaissance à proprement parler

Bien que j'utilise une base no-SQL, je continue, dans le cadre
de ce texte descriptif, à définir un schéma de base de
données et à parler de tables et d'enregistrements. Mais c'est plus une auto-discipline
qu'une contrainte imposée par la base de données.
Quant au vocabulaire, j'aurais pu utiliser S<« collection »> au lieu de S<« table »>,
mais ç'aurait été plus difficile d'utiliser S<« document »> au lieu S<d'« enregistrement »>
car l'une des tables (ou collections si vous préférez) s'appelle S<« Document »>.

Mais tout d'abord, définir la base de données utilisée et les autorisations
d'accès.

=head2 Création de la base de données

La création se fait tout simplement dans le shell C<mongo>.

  $ mongo
  [ message d'accueil ]
  > use exemple
  switched to db exemple

Puis la création d'un utilisateur générique pour la base de données, portant
le même nom que la base de données :

  > db.createUser( { 'user': 'exemple', 'pwd': 's3kr3t', 'roles': [ 'readWrite' ] })

Et pour activer l'authentification, éditer F</etc/mongodb.conf> et changer les S<lignes :>

  # Turn on/off security.  Off is currently the default
  #noauth = true
  #auth = true

en

  # Turn on/off security.  Off is currently the default
  #noauth = true
  auth = true

et redémarrer le serveur MongoDB.

Maintenant, pour se connecter à la base de données sous le shell C<mongo>, il faudra faire

  $ mongo
  [ message d'accueil ]
  > use exemple
  switched to db exemple
  > db.auth('exemple', 's3kr3t')
  1

=head2 Le schéma de base de données

La première table est la table S<« Document ».>
Cela correspond à un fichier numérisé et à ses
avatars successifs. Chaque listing a été scanné en huit fichiers graphiques
environ, donc donnera lieu à huit documents.

La deuxième table est la table S<« Cellule ».>
Elle représente les cellules obtenues en découpant le Document. Les informations de cette table
sont, entre autres, les coordonnées de la Cellule
dans le Document, aussi bien exprimées en
ligne-colonne qu'en coordonnées pixel.
La table contient également le dessin en pixels encodé
en MIME/base64.

La troisième table est la table S<« Caractère ».>
Elle comporte environ 96 enregistrements,
pour les caractères S<« ! »> à S<« } ».> Je rappelle
que j'ai utilisé de l'ASCII 7 bits.
Comme il n'y a pas d'information à stocker, peut-être que
cette table ne sera pas implémentée.

La quatrième table est la table S<« Glyphe ».>
Chaque enregistrement correspond à un tableau à deux dimensions
de bits, représentant le dessin du caractère en pixels noirs et blancs.
Un Caractère est associé à 1 à n Glyphes,
un Glyphe est associé à un caractère et un seul.

Et une cinquième table un peu inattendue, la table S<« Requête »>.
Au début, je pensais faire des requêtes S<« au> fil de S<l'eau » :>
saisir les critères, cliquer sur un bouton et lire le résultat.
Je pense qu'il est préférable d'en faire une entité permanente.
L'utilisateur saisit les critères et on les sauvegarde en base de données.
Puis il clique sur un bouton S<« Recherche »> et le programme applique les critères
sur les Cellules et constitue la liste des Cellules extraites, plus un fichier
graphique où les Cellules extraites sont mises en valeur par un fond coloré.
Par la suite, l'utilisateur peut consulter à plusieurs reprises le résultat de
cette Requête (le fichier graphique déjà constitué) et enchaîner vers les
Cellules sélectionnées grâce à une I<imagemap>.

Certes, avec la création de nouveaux Glyphes, le résultat de la Requête devient
de plus en plus obsolète, car certaines Cellules ne vérifient plus les critères et
d'autres se mettent à les vérifier. Il reste encore utilisable pour consulter les Cellules.
Et l'utilisateur peut de nouveau cliquer sur le bouton S<« Recherche »> pour rafraîchir
le résultat de la requête. C'est à l'utilisateur de décider quand il est souhaitable de déclencher
le (long) rafraîchissement de la Requête et quand il est préférable de continuer avec une
Requête légèrement S<« rassise »>.

=head3 Table des Glyphes

Dans la table des Glyphes, le tout premier enregistrement est généré 
automatiquement. Il s'agit du Glyphe Espace. Lorsque l'utilisateur
saisit le paramètre C<appli> et le mot de passe, le programme vérifie que le
Glyphe Espace existe et, si nécessaire, le crée.

Les autres Glyphes sont créés par copie d'une Cellule.

=head3 Relation entre Cellules et Glyphes

Compte tenu des irrégularités des gouttes d'encre, le dessin en pixels
d'une Cellule
ne correspond pas au dessin épuré d'un Glyphe. On associe
une Cellule à un Glyphe en comparant les pixels et en minimisant
le nombre de pixels différents. Ce nombre, le S<« score »,>
est stocké dans l'enregistrement Cellule.

Il y a un problème avec cette méthode, dans la mesure où une Cellule
peut correspondre à plusieurs Glyphes différents. Si ces Glyphes
dépendent du même Caractère, ce n'est pas grave. Mais si ces Glyphes
représentent des Caractères différents... J'en tiendrai compte
pour mes traitements.

En raison de l'existence systématique d'au moins un Glyphe dans la base de
données (le Glyphe Espace), chaque Cellule aura, dès sa création, un score
et sera associée à au moins un Glyphe. Cela permet de simplifier d'autres
portion des traitements du programme.

=head2 L'architecture des traitements

Voici l'arborescence des pages et des
traitements, dans un ordre  correspondant à peu
près à la chronologie des opérations.

=head3 Ajout de document

La première fonction accessible à partir du menu principal
permet uniquement d'ajouter des noms de document
à la base de données.

Comme cette page est très peu remplie, j'ai décidé de la fusionner
avec la suivante. La séparation logique reste visible cependant.

=head3 Liste des documents

La deuxième fonction donne la liste des documents.
De cette page, on enchaîne vers une page consacrée à un
seul document.

=head3 Document

Dans cette page, on peut spécifier les paramètres
permettant de découper le document en cellules. Cela genère un fichier
graphique matérialisant ce découpage, mais sans
pour autant créer les enregistrements dans la table
S<« Cellule ».>

Une deuxième fonction dans cette page permet
de valider le découpage, avec création des
S<« Cellules ».>

Une troisième fonction permet de lancer l'analyse
des Cellules du Document pour leur associer le
ou les Glyphes les plus ressemblants.

Une quatrième fonction permet de sélectionner
des cellules dans le fichier graphique en fonction
de certains critères (au moins le score, ou le nombre
de Glyphes pour chaque Cellule, mais je n'ai pas
encore choisi les autres critères) et de créer une I<imagemap>
pour les cellules sélectionnées.

La dernière fonction est celle qui permet de
créer la version texte du Document, une fois
que toutes les Cellules ont été reconnues.

=head3 Cellule

Revenons à l'I<imagemap> d'un Document. Elle permet d'accéder
à la page associée à une Cellule. Sur cette page,
on a le dessin en gros pixels de la Cellule et celui
du ou des Glyphes associés à la Cellule. S'il y a beaucoup d'écarts
entre ces deux dessins, l'utilisateur peut créer un nouveau
Glyphe. A priori, le Glyphe créé sera identique à la Cellule
dont il est issu. Si besoin est, je prévoirai une façon de créer
un Glyphe à partir d'un autre Glyphe en effectuant des retouches
(gommer certains pixels, ajouter une goutte d'encre se traduisant 
par un cercle de pixels, etc), mais dans un premier temps, je me contente
de copier le dessin d'une Cellule dans le Glyphe.


=head2 Quadrillage

Pour définir le quadrillage, il faut renseigner
les coordonnées pixel de la Cellule (ou de l'espace)
en ligne 0, colonne 0. Il faut également donner
la taille en pixels (largeur et hauteur) pour les
Cellules du quadrillage. Ces dimensions peuvent
avoir une partie décimale. Ainsi, si on attribue
la valeur 40,34 à la largeur, alors
les abscisses-pixel des Cellules successives
seront 0, 40, 80, 121, 151, 181, 212, etc.
La largeur de chaque Cellule sera arrondie
à S<41 pixels,> tant pis s'il y a un recouvrement
entre deux Cellules voisines.
À moins que j'arrondisse la largeur des Cellules à S<40 pixels,>
ce qui engendrera d'éventuelles lacunes d'un pixel de large entre
deux Cellules voisines.

Il y a encore un écueil de la numérisation dont je n'ai pas parlé.
Lorsque j'ai scanné les listings, le papier n'était pas
toujours bien aligné sur la vitre du scanner.
J'ai beau caler la feuille avec un gros livre,
lorsque je rabat le couvercle du scanner la feuille subit
une légère rotation qu'il faut compenser dans le
découpage en Cellules.

Comme l'angle de rotation est très faible malgré tout,
je remplace la rotation par la combinaison
d'un cisaillement horizontal et d'un cisaillement
vertical. Le cisaillement horizontal s'exprime au choix S<ainsi :>

Tous les N pixels (en hauteur), décaler d'un pixel vers la gauche / la droite.

Toutes les N lignes, décaler d'un pixel vers la gauche / la droite.

Et de même pour le cisaillement vertical. Dans le cas présent, j'ai
opté pour "toutes les N lignes" et "tous les N caractères".

Comme pour la taille des cellules, on admet des valeurs
avec partie décimale. D'autre part, comme ces deux cisaillements
simulent une rotation, leurs paramètres sont liés.
Si le cisaillement horizontal se fait vers la droite,
le cisaillement vertical se fera vers le haut.
Et les valeurs des paramètres N devront être identiques
(pour la règle S<« tous> les N S<pixels »)> ou proportionnelles
S<(« tous> les N S<caractères »).> Cette cohérence est
laissée à la charge de l'utilisateur.

Cette opération de cisaillement, comme le calcul des abscisses-pixel et
des ordonnées-pixel, ne concerne que le positionnement du coin
en haut à gauche de la Cellule. Les côtés de la Cellule extraite
sont purement verticaux ou horizontaux.

Voici un exemple volontairement exagéré de cisaillement horizontal. Vous remarquez que les côtés
verticaux des cellules restent verticaux, même si les cellules ne sont pas
alignées verticalement entre elles.

=for HTML
<img src="ex-cisaillement-horizontal.png" alt="Exemple (exagéré) de cisaillement horizontal" />

De même voici un cisaillement vertical tout aussi exagéré

=for HTML
<img src="ex-cisaillement-vertical.png" alt="Exemple (exagéré) de cisaillement vertical" />

Et la combinaison d'un cisaillement vers la gauche et d'un cisaillement vers le bas
donne une rotation.

=for HTML
<img src="ex-rotation.png" alt="Exemple de rotation (exagéré, mais un peu moins)" />

Et voici un exemple réel, en gros S<plan :>  décalage d'un pixel à gauche toutes les trois lignes,
décalage d'un pixel vers le bas tous les trois caractères. Vous pouvez voir le léger décalage
entre la cellule du S<« o »> et la cellule du S<« g »>, ainsi qu'entre le S<« a »> et le S<« m »>.

=for HTML
<img src="gros-plan-cisaillement.png" alt="Exemple de cisaillements combinés" />

=head2 Comparaison entre une Cellule et un Glyphe

Une fois le découpage effectué, on rogne la Cellule en calculant 
S<l'« enveloppe »> des pixels (I<bounding box> en anglais).
Prenons l'exemple de deux Cellules contenant un signe plus.
Les signes ne sont pas centrés de la même manière dans leur Cellule.

  ----------------  ----------------
  |              |  |              |
  |        *     |  |              |
  |        *     |  |              |
  |        *     |  |      *       |
  |     *******  |  |      *       |
  |        *     |  |      *       |
  |        *     |  |   *******    |
  |        *     |  |      *       |
  |              |  |      *       |
  |              |  |      *       |
  |              |  |              |
  ----------------  ----------------

La comparaison brute de ces deux Cellules donne de nombreuses différences.
Les S<« C<=> »> montrent les pixels noirs communs (deux seulement), 
les S<« C<#> »> montrent les pixels différents (22).

  ----------------  ----------------
  |              |  |              |
  |        #     |  |              |
  |        #     |  |              |
  |        #     |  |      #       |
  |     #=#####  |  |      =       |
  |        #     |  |      #       |
  |        =     |  |   #####=#    |
  |        #     |  |      #       |
  |              |  |      #       |
  |              |  |      #       |
  |              |  |              |
  ----------------  ----------------


Il y a fort à parier
que le Glyphe qui sera associé à la première donnera un mauvais score pour la seconde.
C'est pour cela que l'on calcule l'enveloppe rectangulaire englobant les pixels noirs, pour obtenir des comparaisons
plus significatives.

  Cellule 1         Cellule 2         Glyphe
  ----------------  ----------------  ---------
  |    --------- |  |              |  |   *   |
  |    |   *   | |  |              |  |   *   |
  |    |   *   | |  |  ---------   |  |   *   |
  |    |   *   | |  |  |   *   |   |  |*******|
  |    |*******| |  |  |   *   |   |  |   *   |
  |    |   *   | |  |  |   *   |   |  |   *   |
  |    |   *   | |  |  |*******|   |  |   *   |
  |    |   *   | |  |  |   *   |   |  ---------
  |    --------- |  |  |   *   |   |
  |              |  |  |   *   |   |
  |              |  |  ---------   |
  ----------------  ----------------

Exemple réel de comparaison entre une Cellule et un Glyphe. La Cellule est à gauche
et on peut remarquer le rectangle bleu délimitant la Cellule et le rectangle vert délimitant
l'enveloppe des pixels noirs. Le Glyphe est à droite. Et au milieu, comme dans le programme de lissage,
la représentation en orange des pixels effacés et la représentation en cyan des pixels noircis.

=for HTML
<img src="comparaison-cellule-glyphe.png" alt="Représentation de la comparaison entre une Cellule et un Glyphe" />

=head1 Après la conversion

Une fois tous les documents traités et convertis en fichiers textes, il ne reste plus S<qu'à :>

=over 4

=item 1

Reconstituer les trois fichiers sources complets, en fusionnant les fichiers textes.
Rappelez-vous qu'un listing a donné lieu à en moyenne S<8 documents>.

=item 2

Reconstituer un quatrième fichier source. Le troisième listing comporte des annotations
manuscrites, que j'ai enlevées autant que possible dans les fichiers graphiques numérisés.
Néanmoins, j'applique ces annotations pour constituer un quatrième listing. Faute de disposer
de la date de ces annotations, j'adopte le lendemain de la date du troisième listing.

=item 3

Pour les quatre fichiers sources, passer la commande Emacs C<tabify>, pour remplacer les suites
d'espaces par des tabulations là où cela vaut le coup. En effet, en 1983 et 1984, j'étais
adepte de la solution de facilité consistant à utiliser des tabulations pour l'indentation.

=item 4

Initialiser le dépôt Git du programme Pascal. Pour chacun des quatre fichiers sources, 
le copier dans ce dépôt, en écrasant l'ancienne version, puis lancer un C<commit>.
Dans le message du C<commit>, mentionner le fait que le fichier est placé rétroactivement
sous la licence GPL + Artistic.

=item 5

Ajouter des fichiers F<LICENSE>, F<README> et F<LISEZMOI> et mettre dans le fichier source les
commentaires requis par la GPL. Puis commiter avec la date du jour.

=item 6

Passer un C<untabify> sur le fichier source et commiter, parce que j'ai grandi et mûri depuis 1984 et que
je n'utilise plus de tabulations en dehors des fichiers F<makefile>.

=item 7

Dans le dépôt Git, créer un sous-répertoire pour y mettre les fichiers graphiques issus de la numérisation.

=back

Et maintenant, il ne reste plus qu'à vérifier que cela compile sans erreur, puis à faire évoluer le
programme...

=head1 En guise de conclusion

=head2 Ce que je n'ai pas fait

Je n'ai pas prêté attention aux problèmes de mises à jour concurrentes.
Comme je suis l'unique utilisateur, je me contente d'une session
unique. Ou alors, si c'est très facile avec Dancer2 de gérer
les sessions simultanées, je gèrerai moi-même la synchronisation
entre les quelques sessions que je m'autoriserai à ouvrir.

Le modèle de sécurité est très simple. C'est la même personne (moi)
qui écrit les programmes, gère la base de données, utilise l'application
et exploite le résultat. En d'autres termes, le malfaiteur potentiel
et la victime potentielle sont la même personne.

Retour du S<balancier :>
j'ai quand même activé l'authentification pour la base
de données MongoDB. D'autre part, influencé sans doute par
L<xkcd|https://xkcd.com/327/> et
L<Bobby Tables|http://bobby-tables.com/>,
j'ai imposé des restrictions drastiques à la saisie des noms de document
et des noms de fichier. C'est plus une question de I<cross-site scripting>
que de I<SQL injection> (ou plutôt I<no-SQL injection>).

Troisième mouvement du S<balancier :> bien que j'utilise des expressions régulières
pour vérifier ces noms de document et de fichier, je n'ai pas cherché à lancer
mon application en I<taint mode>. Je ne me fais pas d'illusion, cela plantera.
Quant à l'authentification dans MongoDB, elle m'empêchait d'accéder à la base
alors que je renseignais correctement le mot de passe. Je l'ai donc désactivée.

Puis, dans un quatrième mouvement du balancier, j'ai compris comment faire fonctionner
l'authentification dans le shell C<mongo> et dans les programmes Perl, donc
je l'ai mise en place sur ma base de données et dans mon application.

S<ORM ?> D'une part, c'est bon pour des bases SQL où le schéma est stocké
dans la base et accessible par une API. Donc, inutile d'y songer pour 
MongoDB (encore que certains pourraient essayer). D'autre part, de ce que j'ai
pu comprendre, c'est assez difficile de faire évoluer l'application basée
sur un ORM si la structure de la base de données change. Finalement, masquer
le SQL ou le langage d'accès à MongoDB, cela ne m'intéresse pas.

S<MVC ?> Je n'ai pas essayé. Peut-être que l'utilisation de Dancer2 impose
au moins en partie une architecture MVC, mais en dehors de cela, je n'ai pas
cherché à faire du MVC propre. J'ai quand même cherché à séparer les fonctions
qui produisent du HTML des fonctions qui accèdent à la base de données, mais
c'est plutôt dans l'éventualité d'un plan B remplaçant MongoDB par SQLite
et parce que j'ai commencé par coder des faux accès renvoyant des données S<« en dur »,>
ce n'est pas l'application consciencieuse de l'architecture MVC.

S<AJAX ?> Il faut commencer par apprendre JavaScript. Et ensuite, apprendre AJAX.
Ce n'est pas pour tout de suite.

Dans la même ligne, S<HTML 5 ?> Au début des réunions de Paris.PM, quelqu'un avait
mentionné un article de L<Jamie Zawinski|https://www.jwz.org/> expliquant que son
navigateur Netscape 2 ne lui permettait pas d'afficher certaines pages web avec
des tas de gadgets HTML partout, mais qu'il s'en fichait parce que ces pages ne l'intéressaient
pas. Il souhaitait des pages pour apprendre quelque chose, pas pour s'en prendre plein
les mirettes. Dans cet esprit, j'ai adopté un style minimaliste pour les pages web
de cette application, ce qui m'évite d'avoir à apprendre un système de I<templating>.
De même, pour les explications que vous êtes en train de lire, je les écris en POD
et elles sont traduites en HTML par un convertisseur sans fioritures superflues.

=head2 Mauvaises surprises

J'ai eu quelques mauvaises surprises lorsque j'ai voulu utiliser les différents modules
dont j'ai besoin. Il s'agit peut-être de bugs, ou alors c'est du S<« PECEC »> (I<PEBKAC>
en anglais). Je réétudierai chacun des problèmes lorsque j'aurai un peu plus de latitude
dans mon emploi du temps.

=head3 GD

J'ai déjà mentionné le fait que la conversion RGB -> HSV pouvait donner des valeurs négatives
pour la teinte H. J'ai soumis un ticket sur RT et il a été accepté. Cela devrait être corrigé.
Mais j'ai constaté d'autres problèmes pour la conversion RGB -> HSV ou inverse. Quand j'aurai le
temps, je soumettrai un nouveau ticket.

=head2 Dancer2

Lorsque j'ai voulu afficher un fichier graphique S<avec :>

  <img src='toto.png' alt='titi' />

cela a déclenché un sous-programme de traitement de route et le fichier ne s'est pas affiché.
Heureusment, avec la balise

  <img src='data:image/png;base64,xxx' alt='titi' />

l'affichage se fait correctement. Le fichier HTML est beaucoup plus gros, mais au moins on
voit le dessin. J'avais prévu d'utiliser ce système pour l'affichage des Cellules et des Glyphes,
parce qu'ils sont petits, mais pas pour les gros fichiers correspondant à un Document. J'ai été
obligé de le faire, mais ça fonctionne.

=head3 MongoDB

Lorsque je lis le livre sur MongoDB chez O'Reilly, je lis que le shell MongoDB fournit
une méthode C<find()> qui renvoie une liste de documents vérifiant les critères
en paramètres et une méthode C<findOne> qui en renvoie un seul.
Lorsque je consulte le L<synopsis|https://metacpan.org/pod/MongoDB#SYNOPSIS>
du L<module Perl|https://metacpan.org/pod/MongoDB>, je vois la méthode C<find_one>
qui renvoie le document cherché. Il va de soi qu'il doit exister dans ce module
une méthode C<find> qui renverrait la liste des documents, n'est-ce S<pas ?> Éh bien non.
Dans une autre documentation, le L<tutorial|https://metacpan.org/pod/distribution/MongoDB/lib/MongoDB/Tutorial.pod>,
le paragraphe L<Cursors|https://metacpan.org/pod/distribution/MongoDB/lib/MongoDB/Tutorial.pod#Cursors>
explique que la méthode C<find()> renvoie un curseur qu'il faut dérouler
avec C<next()>. Quand j'ai commencé à écrire des accès à MongoDB en Perl, je n'avais
pas encore lu cette documentation, donc il m'a fallu un peu de débugage
(avec C<say> et C<YAML::Dump>) pour comprendre qu'il fallait utiliser C<next>
ou mieux, C<all>.

Un point qui aurait pu me faire perdre beaucoup de S<temps :> MongoDB fait une différence 
entre un nombre et une chaîne de caractères constituée de caractères tous numériques. C'est marqué 
à la page 8 du livre chez O'Reilly. Les deux documents ci-dessous sont S<différents :>

  { "foo" : 3 }
  { "foo" : "3" }

Mes premières tentatives pour accéder à l'enregistrement d'une cellule en fonction de sa ligne
et de sa colonne ont échoué, car la ligne et la colonne étaient extraits de l'URL traité par Dancer,
donc c'était des caractères. En d'autres termes, les critères de sélection étaient

  { "doc" : "ex1", "l" : "0", "c" : "0" }

alors que la Cellule contenait (entre autres) :

  { "doc" : "ex1", "l" : 0, "c" : 0 }

Heureusement d'une part que j'ai feuilleté le livre à la bonne page et d'autre part que je me
souvenais d'un problème évoqué par Sébastien lors d'une L<réunion de Paris.PM|http://paris.mongueurs.net/meetings/2013/0515.html#t>.


=head2 Bonnes Surprises

Il y a eu quand même des bonnes surprises. Notamment, dans C<GD>, l'orientation par défaut
des coordonnées. Les coordonnées X croissent de gauche à droite (comme habituellement), tandis
que les coordonnées Y croissent du haut vers le bas, à l'inverse de l'habitude. Mais cela 
coïncide avec le sens habituel de variation des coordonnées ligne-colonne dans un fichier texte en 
police à espacement fixe. D'où une simplification significative des opérations de 
conversion LC -> XY.

Une autre bonne surprise, c'est avec GitHub. J'ai écrit le présent texte en POD,
parce que c'est le système le plus simple pour écrire des documents et parce qu'il existe
de nombreux outils de conversion en HTML, en LATEX, etc. J'avais prévu de consacrer un peu
de temps à écrire un tel convertisseur (en me basant bien sûr sur les modules de la distribution
standard et de CPAN). Éh bien cela n'a pas été nécessaire. Rien que le fait d'envoyer un fichier
POD sur GitHub fait qu'il est automatiquement traduit en HTML. Il y a juste un petit
problème avec les blancs insécables.

Au moment où j'écris ces lignes, je n'ai pas encore mis en place le système des Requêtes.
Il est trop tôt pour conclure sur le problème des S<« l »> (S<« L »> minuscules),
des S<« I »> (S<« i »> majuscules) et des S<« 1 »> (chiffres S<« un »>). Je pense néanmoins
que cela se résoudra sans mal. En revanche, entre les tirets et les blancs soulignés, compte tenu
de la réduction à l'enveloppe rectangulaire des pixels noirs, la similarité des Cellules est
très problématique. Heureusement, à l'époque (1983--1984) je n'utilisais aucun blanc souligné. Donc le problème
est éludé. Pour l'instant.

Une bonne surprise dont je ne me suis pas rendu compte tout de suite. MongoDB permet de stocker
des structures de données complexes dans un même enregistrement, comme un tableau de valeurs scalaires,
ou un tableau de hachages. Ce n'est pas le cas avec les bases  de données SQL puristes qui prônent
l'adoption des formes normales S<successives :> si vous voulez stocker une donnée indicée, vous devez
créer une nouvelle table avec, comme clé, la clé de la table d'origine plus la valeur de l'indice.
Cela dit, du côté de SQL, S<« ils »> sont en train de revenir à des pratiques plus... pratiques et
à autoriser des colonnes de base de données de type C<JSON>, donc avec la possibilité de définir
des tableaux et de les emboîter.

=head1 Compléments

=head2 Lissage des fichiers graphiques

L'algorithme utilisé est du même type que celui du
jeu de la vie de John Conway. Il y a quelques différences de
comportement. Par exemple, dans le jeu de la vie, la population peut s'étendre.
Dans le lissage, la population reste confinée dans son rectangle initial
(ou enveloppe ou I<bounding box>).
C'est facile à comprendre. Prenons un pixel blanc juste à l'extérieur
du rectangle initial, par exemple juste au-dessus.  Les seuls pixels
voisins qui peuvent être occupés (noirs) sont les trois pixels du dessous
(pour la variante à 8 voisins) ou le pixel du dessous (pour
la variante à 4 voisins). Ce pixel ne peut donc pas devenir noir.
À l'inverse, pour le jeu de la vie, nous avons les glisseurs, les
vaisseaux, les canons à glisseurs, etc.

Que peut-on dire à propos de l'itération du S<processus ?> Puisque l'on ne peut
pas s'étendre à l'extérieur du rectangle initial, le nombre de possibilités
est fini (majoré par 2**N, N étant le nombre total de pixels noirs et blancs
dans le rectangle initial). On arrivera nécessairement à une situation périodique
au bout d'un temps plus ou moins long. Mathématiquement parlant, le nombre d'itérations
pour aborder la partie périodique et le nombre d'itérations dans une période
sont majorés par 2**N, mais dans la pratique je pense que cela sera beaucoup plus faible,
à taille humaine. Notamment, je pense que la situation finale sera une
situation statique, c'est-à-dire avec une période 1. Pas de clignotants de
période 2 comme avec le jeu de la vie.

Si l'on admet une extension infinie dans les deux dimensions, il
existe des clignotants. L'un des deux motifs ci-dessous est un clignotant
pour la version à S<4 voisins,> l'autre pour la version à S<8 voisins.>

  .x.x.x.x.x   .x.x.x.x.x
  x.x.x.x.x.   .x.x.x.x.x
  .x.x.x.x.x   .x.x.x.x.x
  x.x.x.x.x.   .x.x.x.x.x
  .x.x.x.x.x   .x.x.x.x.x
  x.x.x.x.x.   .x.x.x.x.x

Mais dans mon cas, chaque motif est entouré en haut, en bas,
à gauche et à droite par des lignes blanches. Donc les motifs
S<ci-dessous :>

  ............   ...........
  ..x.x.x.x.x.   .x.x.x.x.x.
  .x.x.x.x.x..   .x.x.x.x.x.
  ..x.x.x.x.x.   .x.x.x.x.x.
  .x.x.x.x.x..   .x.x.x.x.x.
  ..x.x.x.x.x.   .x.x.x.x.x.
  .x.x.x.x.x..   .x.x.x.x.x.
  ............   ...........

se réduiront petit à petit.

  ............   ...........
  ...x.x.x.x..   ...........
  ..x.x.x.x.x.   ..x.x.x.x..
  .x.x.x.x.x..   ..x.x.x.x..
  ..x.x.x.x.x.   ..x.x.x.x..
  .x.x.x.x.x..   ..x.x.x.x..
  ..x.x.x.x...   ...........
  ............   ...........

  ............   ...........
  ....x.x.x...   ...........
  ...x.x.x.x..   ...........
  ..x.x.x.x.x.   ...x.x.x...
  .x.x.x.x.x..   ...x.x.x...
  ..x.x.x.x...   ...........
  ...x.x.x....   ...........
  ............   ...........

  ............   ...........
  .....x.x....   ...........
  ....x.x.x...   ...........
  ...x.x.x.x..   ...........
  ..x.x.x.x...   ...........
  ...x.x.x....   ...........
  ....x.x.....   ...........
  ............   ...........

et ainsi de suite.

=head2 Rotation et cisaillements

Dans le formulaire définissant les cisaillements, les valeurs sont 
données en S<« pixels> toutes les I<N> S<lignes »> (ou S<« colonnes »>.
Ici, on ignore le facteur d'échelle et on considère que les cisaillements
sont spécifiés en S<« pixels> tous les I<n> S<pixels »>.

Une rotation dans le plan se traduit par l'équation
suivante si les coordonnées sont exprimées dans un
repère S<orthonormé :>

  (x')   (cos a -sin a) (x)
  (  ) = (            ) ( )
  (y')   (sin a  cos a) (y)

Si l'angle a (en radians) est faible, on a :

  sin a ≅ a
  cos a ≅ 1

ce qui donne

  (x')   (1 -a) (x)
  (  ) = (    ) ( )
  (y')   (a  1) (y)

L'équation d'un cisaillement horizontal S<est :>

  (x')   (1 -a) (x)
  (  ) = (    ) ( )
  (y')   (0  1) (y)

la valeur I<a> étant l'inverse du nombre I<n>
de la spécification S<« un> pixel tous les I<n> S<pixels »>,
avec un signe moins éventuel selon le sens du cisaillement.
De même, l'équation d'un cisaillement vertical S<est :>

  (x')   (1  0) (x)
  (  ) = (    ) ( )
  (y')   (a  1) (y)

La composition de ces deux cisaillements S<(« f> rond S<g »> ou S<« g> rond S<f »> en mathématiques)
donne l'une de ces deux équations, selon le sens de la S<composition :>

  (x')   (1    -a) (x)          (x')   (1-a² -a) (x)
  (  ) = (       ) ( )          (  ) = (       ) ( )
  (y')   (a  1-a²) (y)          (y')   (a     1) (y)

La valeur de a étant faible, on néglige son carré (on l'a déjà fait pour l'approximation
du cosinus) et on retombe sur l'équation de la rotation.
Mais j'ai préféré parlé de S<« combinaison »> que de S<« composition »,> pour faire disparaître
d'emblée le terme en a².

=head1 LICENCE

Texte diffusé sous la licence CC-BY-NC-ND : Creative Commons avec clause de paternité, excluant l'utilisation commerciale et excluant la modification. 

Certaines illustrations sont diffusées avec une licence libre différente. Celle-ci est mentionnée à la suite de l'illustration.
